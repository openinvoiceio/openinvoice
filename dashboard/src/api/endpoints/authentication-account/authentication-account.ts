/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * Invoicence API
 * Description
 * OpenAPI spec version: 1.0.0
 */
import { useMutation, useQuery, useSuspenseQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from "@tanstack/react-query";
import { axiosInstance } from "../../../lib/api/client";
import type { ErrorType } from "../../../lib/api/client";
import type {
  AuthenticatedByPasswordResponse,
  AuthenticatedResponse,
  AuthenticationResponse,
  ConflictResponse,
  EmailVerificationInfoResponse,
  ErrorResponse,
  ForbiddenResponse,
  LoginBody,
  ReauthenticateBody,
  SignupBody,
  UnauthenticatedResponse,
  VerifyEmailBody,
  VerifyPhoneBody,
} from "../../models";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Login using a username-password or email-password combination.

 * @summary Login
 */
export const login = (
  client: "app" | "browser",
  loginBody: LoginBody,
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<AuthenticatedByPasswordResponse>(
    {
      url: `/api/${client}/v1/auth/login`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: loginBody,
      signal,
    },
    options,
  );
};

export const getLoginMutationOptions = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse | ConflictResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof login>>,
    TError,
    { client: "app" | "browser"; data: LoginBody },
    TContext
  >;
  request?: SecondParameter<typeof axiosInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof login>>,
  TError,
  { client: "app" | "browser"; data: LoginBody },
  TContext
> => {
  const mutationKey = ["login"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof login>>,
    { client: "app" | "browser"; data: LoginBody }
  > = (props) => {
    const { client, data } = props ?? {};

    return login(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type LoginMutationResult = NonNullable<
  Awaited<ReturnType<typeof login>>
>;
export type LoginMutationBody = LoginBody;
export type LoginMutationError = ErrorType<
  ErrorResponse | AuthenticationResponse | ConflictResponse
>;

/**
 * @summary Login
 */
export const useLogin = <
  TError = ErrorType<ErrorResponse | AuthenticationResponse | ConflictResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof login>>,
      TError,
      { client: "app" | "browser"; data: LoginBody },
      TContext
    >;
    request?: SecondParameter<typeof axiosInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof login>>,
  TError,
  { client: "app" | "browser"; data: LoginBody },
  TContext
> => {
  const mutationOptions = getLoginMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Whether or not `username`, `email`, `phone` or combination of those are
required depends on the configuration of django-allauth. Additionally,
if a custom signup form is used there may be other custom properties
required.

 * @summary Signup
 */
export const signup = (
  client: "app" | "browser",
  signupBody: SignupBody,
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<AuthenticatedByPasswordResponse>(
    {
      url: `/api/${client}/v1/auth/signup`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: signupBody,
      signal,
    },
    options,
  );
};

export const getSignupMutationOptions = <
  TError = ErrorType<
    | ErrorResponse
    | AuthenticationResponse
    | ForbiddenResponse
    | ConflictResponse
  >,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof signup>>,
    TError,
    { client: "app" | "browser"; data: SignupBody },
    TContext
  >;
  request?: SecondParameter<typeof axiosInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof signup>>,
  TError,
  { client: "app" | "browser"; data: SignupBody },
  TContext
> => {
  const mutationKey = ["signup"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof signup>>,
    { client: "app" | "browser"; data: SignupBody }
  > = (props) => {
    const { client, data } = props ?? {};

    return signup(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type SignupMutationResult = NonNullable<
  Awaited<ReturnType<typeof signup>>
>;
export type SignupMutationBody = SignupBody;
export type SignupMutationError = ErrorType<
  ErrorResponse | AuthenticationResponse | ForbiddenResponse | ConflictResponse
>;

/**
 * @summary Signup
 */
export const useSignup = <
  TError = ErrorType<
    | ErrorResponse
    | AuthenticationResponse
    | ForbiddenResponse
    | ConflictResponse
  >,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof signup>>,
      TError,
      { client: "app" | "browser"; data: SignupBody },
      TContext
    >;
    request?: SecondParameter<typeof axiosInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof signup>>,
  TError,
  { client: "app" | "browser"; data: SignupBody },
  TContext
> => {
  const mutationOptions = getSignupMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Obtain email verification information, given the token that was sent to
the user by email.

 * @summary Get email verification information
 */
export const getVerifyEmail = (
  client: "app" | "browser",
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<EmailVerificationInfoResponse>(
    { url: `/api/${client}/v1/auth/email/verify`, method: "GET", signal },
    options,
  );
};

export const getGetVerifyEmailQueryKey = (client?: "app" | "browser") => {
  return [`/api/${client}/v1/auth/email/verify`] as const;
};

export const getGetVerifyEmailQueryOptions = <
  TData = Awaited<ReturnType<typeof getVerifyEmail>>,
  TError = ErrorType<ErrorResponse | ConflictResponse>,
>(
  client: "app" | "browser",
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getVerifyEmail>>, TError, TData>
    >;
    request?: SecondParameter<typeof axiosInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetVerifyEmailQueryKey(client);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getVerifyEmail>>> = ({
    signal,
  }) => getVerifyEmail(client, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!client,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getVerifyEmail>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetVerifyEmailQueryResult = NonNullable<
  Awaited<ReturnType<typeof getVerifyEmail>>
>;
export type GetVerifyEmailQueryError = ErrorType<
  ErrorResponse | ConflictResponse
>;

export function useGetVerifyEmail<
  TData = Awaited<ReturnType<typeof getVerifyEmail>>,
  TError = ErrorType<ErrorResponse | ConflictResponse>,
>(
  client: "app" | "browser",
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getVerifyEmail>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getVerifyEmail>>,
          TError,
          Awaited<ReturnType<typeof getVerifyEmail>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof axiosInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetVerifyEmail<
  TData = Awaited<ReturnType<typeof getVerifyEmail>>,
  TError = ErrorType<ErrorResponse | ConflictResponse>,
>(
  client: "app" | "browser",
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getVerifyEmail>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getVerifyEmail>>,
          TError,
          Awaited<ReturnType<typeof getVerifyEmail>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof axiosInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetVerifyEmail<
  TData = Awaited<ReturnType<typeof getVerifyEmail>>,
  TError = ErrorType<ErrorResponse | ConflictResponse>,
>(
  client: "app" | "browser",
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getVerifyEmail>>, TError, TData>
    >;
    request?: SecondParameter<typeof axiosInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get email verification information
 */

export function useGetVerifyEmail<
  TData = Awaited<ReturnType<typeof getVerifyEmail>>,
  TError = ErrorType<ErrorResponse | ConflictResponse>,
>(
  client: "app" | "browser",
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getVerifyEmail>>, TError, TData>
    >;
    request?: SecondParameter<typeof axiosInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetVerifyEmailQueryOptions(client, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetVerifyEmailSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getVerifyEmail>>,
  TError = ErrorType<ErrorResponse | ConflictResponse>,
>(
  client: "app" | "browser",
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getVerifyEmail>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof axiosInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetVerifyEmailQueryKey(client);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getVerifyEmail>>> = ({
    signal,
  }) => getVerifyEmail(client, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getVerifyEmail>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetVerifyEmailSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getVerifyEmail>>
>;
export type GetVerifyEmailSuspenseQueryError = ErrorType<
  ErrorResponse | ConflictResponse
>;

export function useGetVerifyEmailSuspense<
  TData = Awaited<ReturnType<typeof getVerifyEmail>>,
  TError = ErrorType<ErrorResponse | ConflictResponse>,
>(
  client: "app" | "browser",
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getVerifyEmail>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof axiosInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetVerifyEmailSuspense<
  TData = Awaited<ReturnType<typeof getVerifyEmail>>,
  TError = ErrorType<ErrorResponse | ConflictResponse>,
>(
  client: "app" | "browser",
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getVerifyEmail>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof axiosInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetVerifyEmailSuspense<
  TData = Awaited<ReturnType<typeof getVerifyEmail>>,
  TError = ErrorType<ErrorResponse | ConflictResponse>,
>(
  client: "app" | "browser",
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getVerifyEmail>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof axiosInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get email verification information
 */

export function useGetVerifyEmailSuspense<
  TData = Awaited<ReturnType<typeof getVerifyEmail>>,
  TError = ErrorType<ErrorResponse | ConflictResponse>,
>(
  client: "app" | "browser",
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getVerifyEmail>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof axiosInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetVerifyEmailSuspenseQueryOptions(client, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Complete the email verification process. Depending on the configuration,
email addresses are either verified by opening a link that is sent to
their email address, or, by inputting a code that is sent. On the API,
both cases are handled identically. Meaning, the required key is either
the one from the link, or, the code itself.

Note that a status code of 401 does not imply failure. It indicates that
the email verification was successful, yet, the user is still not signed
in. For example, in case `ACCOUNT_LOGIN_ON_EMAIL_CONFIRMATION` is set to
`False`, a 401 is returned when verifying as part of login/signup.

 * @summary Verify an email
 */
export const verifyEmail = (
  client: "app" | "browser",
  verifyEmailBody: VerifyEmailBody,
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<AuthenticatedResponse>(
    {
      url: `/api/${client}/v1/auth/email/verify`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: verifyEmailBody,
      signal,
    },
    options,
  );
};

export const getVerifyEmailMutationOptions = <
  TError = ErrorType<
    ErrorResponse | UnauthenticatedResponse | ConflictResponse
  >,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof verifyEmail>>,
    TError,
    { client: "app" | "browser"; data: VerifyEmailBody },
    TContext
  >;
  request?: SecondParameter<typeof axiosInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof verifyEmail>>,
  TError,
  { client: "app" | "browser"; data: VerifyEmailBody },
  TContext
> => {
  const mutationKey = ["verifyEmail"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof verifyEmail>>,
    { client: "app" | "browser"; data: VerifyEmailBody }
  > = (props) => {
    const { client, data } = props ?? {};

    return verifyEmail(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type VerifyEmailMutationResult = NonNullable<
  Awaited<ReturnType<typeof verifyEmail>>
>;
export type VerifyEmailMutationBody = VerifyEmailBody;
export type VerifyEmailMutationError = ErrorType<
  ErrorResponse | UnauthenticatedResponse | ConflictResponse
>;

/**
 * @summary Verify an email
 */
export const useVerifyEmail = <
  TError = ErrorType<
    ErrorResponse | UnauthenticatedResponse | ConflictResponse
  >,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof verifyEmail>>,
      TError,
      { client: "app" | "browser"; data: VerifyEmailBody },
      TContext
    >;
    request?: SecondParameter<typeof axiosInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof verifyEmail>>,
  TError,
  { client: "app" | "browser"; data: VerifyEmailBody },
  TContext
> => {
  const mutationOptions = getVerifyEmailMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Complete the phone number verification process. Note that a status code
of 401 does not imply failure. It merely indicates that the phone number
verification was successful, yet, the user is still not signed in.

 * @summary Verify a phone number
 */
export const verifyPhone = (
  client: "app" | "browser",
  verifyPhoneBody: VerifyPhoneBody,
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<AuthenticatedResponse>(
    {
      url: `/api/${client}/v1/auth/phone/verify`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: verifyPhoneBody,
      signal,
    },
    options,
  );
};

export const getVerifyPhoneMutationOptions = <
  TError = ErrorType<
    ErrorResponse | UnauthenticatedResponse | ConflictResponse
  >,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof verifyPhone>>,
    TError,
    { client: "app" | "browser"; data: VerifyPhoneBody },
    TContext
  >;
  request?: SecondParameter<typeof axiosInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof verifyPhone>>,
  TError,
  { client: "app" | "browser"; data: VerifyPhoneBody },
  TContext
> => {
  const mutationKey = ["verifyPhone"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof verifyPhone>>,
    { client: "app" | "browser"; data: VerifyPhoneBody }
  > = (props) => {
    const { client, data } = props ?? {};

    return verifyPhone(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type VerifyPhoneMutationResult = NonNullable<
  Awaited<ReturnType<typeof verifyPhone>>
>;
export type VerifyPhoneMutationBody = VerifyPhoneBody;
export type VerifyPhoneMutationError = ErrorType<
  ErrorResponse | UnauthenticatedResponse | ConflictResponse
>;

/**
 * @summary Verify a phone number
 */
export const useVerifyPhone = <
  TError = ErrorType<
    ErrorResponse | UnauthenticatedResponse | ConflictResponse
  >,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof verifyPhone>>,
      TError,
      { client: "app" | "browser"; data: VerifyPhoneBody },
      TContext
    >;
    request?: SecondParameter<typeof axiosInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof verifyPhone>>,
  TError,
  { client: "app" | "browser"; data: VerifyPhoneBody },
  TContext
> => {
  const mutationOptions = getVerifyPhoneMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * In order to safeguard the account, some actions require the user to be
recently authenticated.  If you try to perform such an action without
having been recently authenticated, a `401` status is returned, listing
flows that can be performed to reauthenticate. One such flow is the flow
with ID `reauthenticate`, which allows for the user to input the
password. This is the endpoint related towards that flow.

 * @summary Reauthenticate
 */
export const reauthenticate = (
  client: "app" | "browser",
  reauthenticateBody: ReauthenticateBody,
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<AuthenticatedByPasswordResponse>(
    {
      url: `/api/${client}/v1/auth/reauthenticate`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: reauthenticateBody,
      signal,
    },
    options,
  );
};

export const getReauthenticateMutationOptions = <
  TError = ErrorType<ErrorResponse>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof reauthenticate>>,
    TError,
    { client: "app" | "browser"; data: ReauthenticateBody },
    TContext
  >;
  request?: SecondParameter<typeof axiosInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof reauthenticate>>,
  TError,
  { client: "app" | "browser"; data: ReauthenticateBody },
  TContext
> => {
  const mutationKey = ["reauthenticate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof reauthenticate>>,
    { client: "app" | "browser"; data: ReauthenticateBody }
  > = (props) => {
    const { client, data } = props ?? {};

    return reauthenticate(client, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ReauthenticateMutationResult = NonNullable<
  Awaited<ReturnType<typeof reauthenticate>>
>;
export type ReauthenticateMutationBody = ReauthenticateBody;
export type ReauthenticateMutationError = ErrorType<ErrorResponse>;

/**
 * @summary Reauthenticate
 */
export const useReauthenticate = <
  TError = ErrorType<ErrorResponse>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof reauthenticate>>,
      TError,
      { client: "app" | "browser"; data: ReauthenticateBody },
      TContext
    >;
    request?: SecondParameter<typeof axiosInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof reauthenticate>>,
  TError,
  { client: "app" | "browser"; data: ReauthenticateBody },
  TContext
> => {
  const mutationOptions = getReauthenticateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
